{"version":3,"sources":["../../src/js/BinarySearchTree.js"],"names":["BinarySearchTree","constructor","rootComparable","_root","_size","initiateRandomTree","nrOfElements","mRandom","Math","floor","random","tree","getSize","insert","getRoot","comparable","currentNode","added","getComparable","getRightTree","setRightTree","getLeftTree","setLeftTree","inOrderTraversal","array","visited","length","includes","push","getParent","findNode"],"mappings":"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","file":"BinarySearchTree.js","sourcesContent":["import Node from './Node'\r\n\r\nexport default class BinarySearchTree {\r\n  constructor(rootComparable) {\r\n    this._root = new Node(rootComparable, null);\r\n    this._size = 1;\r\n  }\r\n\r\n  initiateRandomTree(nrOfElements) {\r\n    var mRandom = function() {\r\n      return Math.floor((Math.random() * nrOfElements * 10) + 1);\r\n    }\r\n    var tree = new BinarySearchTree(mRandom());\r\n\r\n    while (this.getSize() < nrOfElements) {\r\n      this.insert(mRandom());\r\n    }\r\n  }\r\n\r\n  getRoot() {\r\n    return this._root;\r\n  }\r\n\r\n  getSize() {\r\n    return this._size;\r\n  }\r\n\r\n  insert(comparable) {\r\n    let currentNode = this.getRoot();\r\n    let added = false;\r\n\r\n    while(added === false) {\r\n      if (comparable === currentNode.getComparable()) {\r\n        return false; //Comparable already in tree.\r\n      }\r\n      else if (comparable > currentNode.getComparable()) {\r\n        if (currentNode.getRightTree() === null) {\r\n          currentNode.setRightTree(new Node(comparable, currentNode));\r\n          added = true;\r\n        }\r\n        else {\r\n          currentNode = currentNode.getRightTree();\r\n        }\r\n      }\r\n      else {\r\n        if (currentNode.getLeftTree() === null) {\r\n          currentNode.setLeftTree(new Node(comparable, currentNode));\r\n          added = true;\r\n        }\r\n        else {\r\n          currentNode = currentNode.getLeftTree();\r\n        }\r\n      }\r\n    }\r\n\r\n    this._size++;\r\n    return true;\r\n  }\r\n\r\n  inOrderTraversal() {\r\n    var array = [];\r\n    var visited = [];\r\n    var currentNode = this.getRoot();\r\n\r\n    if (currentNode.getComparable() === null) {\r\n      return array;\r\n    }\r\n\r\n    //While all nodes have not been visited\r\n    while (visited.length < this.getSize()) {\r\n      //While current node is not visited\r\n      while (!visited.includes(currentNode)) {\r\n        //Go to most left node from currentNode\r\n        while (currentNode.getLeftTree() != null && !visited.includes(currentNode.getLeftTree())) {\r\n          currentNode = currentNode.getLeftTree();\r\n        }\r\n\r\n        //Put currentNode in array and mark currentNode as visited\r\n        array.push(currentNode.getComparable());\r\n        visited.push(currentNode);\r\n\r\n        //Go to right node if there is one\r\n        if (currentNode.getRightTree() != null && !visited.includes(currentNode.getRightTree())) {\r\n          currentNode = currentNode.getRightTree();\r\n        }\r\n      }\r\n\r\n      //Go back to firstNode with an unvisited parent\r\n      while (currentNode.getParent() != null && visited.includes(currentNode.getParent())) {\r\n        currentNode = currentNode.getParent();\r\n      }\r\n\r\n      //If not rootNode go to the unvisited parent\r\n      if (currentNode.getParent() != null) {\r\n        currentNode = currentNode.getParent();\r\n      }\r\n    }\r\n\r\n    return array;\r\n  }\r\n\r\n  findNode(comparable) {\r\n    var currentNode = this.getRoot();\r\n\r\n    while(currentNode != null && comparable != currentNode.getComparable()) {\r\n      if (comparable > currentNode.getComparable()) {\r\n        currentNode = currentNode.getRightTree();\r\n      }\r\n      else {\r\n        currentNode = currentNode.getLeftTree();\r\n      }\r\n    }\r\n\r\n    return currentNode;\r\n  }\r\n}\r\n"]}