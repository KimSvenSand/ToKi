{"version":3,"sources":["../../src/js/BinarySearchTree.js"],"names":["BinarySearchTree","constructor","rootComparable","_root","getRoot","insert","comparable","currentNode","added","getComparable","getRightTree","setRightTree","getLeftTree","setLeftTree","inOrderTraversal","array","visited","rootVisits","includes","push","getParent","findNode"],"mappings":";;;;;;AAAA;;;;;;AAEe,MAAMA,gBAAN,CAAuB;AACpCC,cAAYC,cAAZ,EAA4B;AAC1B,SAAKC,KAAL,GAAa,mBAASD,cAAT,EAAyB,IAAzB,CAAb;AACD;;AAEDE,YAAU;AACR,WAAO,KAAKD,KAAZ;AACD;;AAEDE,SAAOC,UAAP,EAAmB;AACjB,QAAIC,cAAc,KAAKH,OAAL,EAAlB;AACA,QAAII,QAAQ,KAAZ;;AAEA,WAAMA,UAAU,KAAhB,EAAuB;AACrB,UAAIF,eAAeC,YAAYE,aAAZ,EAAnB,EAAgD;AAC9C,eAAO,KAAP,CAD8C,CAChC;AACf,OAFD,MAGK,IAAIH,aAAaC,YAAYE,aAAZ,EAAjB,EAA8C;AACjD,YAAIF,YAAYG,YAAZ,OAA+B,IAAnC,EAAyC;AACvCH,sBAAYI,YAAZ,CAAyB,mBAASL,UAAT,EAAqBC,WAArB,CAAzB;AACAC,kBAAQ,IAAR;AACD,SAHD,MAIK;AACHD,wBAAcA,YAAYG,YAAZ,EAAd;AACD;AACF,OARI,MASA;AACH,YAAIH,YAAYK,WAAZ,OAA8B,IAAlC,EAAwC;AACtCL,sBAAYM,WAAZ,CAAwB,mBAASP,UAAT,EAAqBC,WAArB,CAAxB;AACAC,kBAAQ,IAAR;AACD,SAHD,MAIK;AACHD,wBAAcA,YAAYK,WAAZ,EAAd;AACD;AACF;AACF;;AAED,WAAO,IAAP;AACD;;AAEDE,qBAAmB;AACjB,QAAIC,QAAQ,EAAZ;AACA,QAAIC,UAAU,EAAd;AACA,QAAIC,aAAa,CAAjB;AACA,QAAIV,cAAc,KAAKH,OAAL,EAAlB;;AAEA,QAAIG,YAAYE,aAAZ,OAAgC,IAApC,EAA0C;AACxC,aAAOM,KAAP;AACD;;AAED,WAAOE,cAAc,CAArB,EAAwB;AACtB,UAAIV,gBAAgB,KAAKH,OAAL,EAApB,EAAoC;AAClCa;AACD;;AAED,aAAO,CAACD,QAAQE,QAAR,CAAiBX,WAAjB,CAAR,EAAuC;AACrC,eAAOA,YAAYK,WAAZ,MAA6B,IAA7B,IAAqC,CAACI,QAAQE,QAAR,CAAiBX,YAAYK,WAAZ,EAAjB,CAA7C,EAA0F;AACxFL,wBAAcA,YAAYK,WAAZ,EAAd;AACD;AACDG,cAAMI,IAAN,CAAWZ,YAAYE,aAAZ,EAAX;AACAO,gBAAQG,IAAR,CAAaZ,WAAb;;AAEA,YAAIA,YAAYG,YAAZ,MAA8B,IAA9B,IAAsC,CAACM,QAAQE,QAAR,CAAiBX,YAAYG,YAAZ,EAAjB,CAA3C,EAAyF;AACvFH,wBAAcA,YAAYG,YAAZ,EAAd;AACD;AACF;;AAED,aAAOH,YAAYa,SAAZ,MAA2B,IAA3B,IAAmCJ,QAAQE,QAAR,CAAiBX,YAAYa,SAAZ,EAAjB,CAA1C,EAAqF;AACnFb,sBAAcA,YAAYa,SAAZ,EAAd;AACD;;AAED,UAAIb,YAAYa,SAAZ,MAA2B,IAA/B,EAAqC;AACnCb,sBAAcA,YAAYa,SAAZ,EAAd;AACD;AACF;;AAED,WAAOL,KAAP;AACD;;AAEDM,WAASf,UAAT,EAAqB;AACnB,QAAIC,cAAc,KAAKH,OAAL,EAAlB;;AAEA,WAAMG,eAAe,IAAf,IAAuBD,cAAcC,YAAYE,aAAZ,EAA3C,EAAwE;AACtE,UAAIH,aAAaC,YAAYE,aAAZ,EAAjB,EAA8C;AAC5CF,sBAAcA,YAAYG,YAAZ,EAAd;AACD,OAFD,MAGK;AACHH,sBAAcA,YAAYK,WAAZ,EAAd;AACD;AACF;;AAED,WAAOL,WAAP;AACD;AA5FmC;kBAAjBP,gB","file":"BinarySearchTree.js","sourcesContent":["import Node from './Node'\n\nexport default class BinarySearchTree {\n  constructor(rootComparable) {\n    this._root = new Node(rootComparable, null);\n  }\n\n  getRoot() {\n    return this._root;\n  }\n\n  insert(comparable) {\n    let currentNode = this.getRoot();\n    let added = false;\n\n    while(added === false) {\n      if (comparable === currentNode.getComparable()) {\n        return false; //Comparable already in tree.\n      }\n      else if (comparable > currentNode.getComparable()) {\n        if (currentNode.getRightTree() === null) {\n          currentNode.setRightTree(new Node(comparable, currentNode));\n          added = true;\n        }\n        else {\n          currentNode = currentNode.getRightTree();\n        }\n      }\n      else {\n        if (currentNode.getLeftTree() === null) {\n          currentNode.setLeftTree(new Node(comparable, currentNode));\n          added = true;\n        }\n        else {\n          currentNode = currentNode.getLeftTree();\n        }\n      }\n    }\n\n    return true;\n  }\n\n  inOrderTraversal() {\n    var array = [];\n    var visited = [];\n    var rootVisits = 1;\n    var currentNode = this.getRoot();\n\n    if (currentNode.getComparable() === null) {\n      return array;\n    }\n\n    while (rootVisits <= 3) {\n      if (currentNode === this.getRoot()) {\n        rootVisits++;\n      }\n\n      while (!visited.includes(currentNode)) {\n        while (currentNode.getLeftTree() != null && !visited.includes(currentNode.getLeftTree())) {\n          currentNode = currentNode.getLeftTree();\n        }\n        array.push(currentNode.getComparable());\n        visited.push(currentNode);\n\n        if (currentNode.getRightTree() != null && !visited.includes(currentNode.getRightTree())) {\n          currentNode = currentNode.getRightTree();\n        }\n      }\n\n      while (currentNode.getParent() != null && visited.includes(currentNode.getParent())) {\n        currentNode = currentNode.getParent();\n      }\n\n      if (currentNode.getParent() != null) {\n        currentNode = currentNode.getParent();\n      }\n    }\n\n    return array;\n  }\n\n  findNode(comparable) {\n    var currentNode = this.getRoot();\n\n    while(currentNode != null && comparable != currentNode.getComparable()) {\n      if (comparable > currentNode.getComparable()) {\n        currentNode = currentNode.getRightTree();\n      }\n      else {\n        currentNode = currentNode.getLeftTree();\n      }\n    }\n\n    return currentNode;\n  }\n}\n"]}