{"version":3,"sources":["../../src/js/BinarySearchTree.js"],"names":["BinarySearchTree","constructor","rootComparable","_root","_size","initiateRandomTree","nrOfElements","mRandom","Math","floor","random","tree","getSize","insert","getRoot","comparable","currentNode","added","getComparable","getRightTree","setRightTree","getLeftTree","setLeftTree","inOrderTraversal","array","visited","length","includes","push","getParent","findNode"],"mappings":";;;;;;AAAA;;;;;;AAEe,MAAMA,gBAAN,CAAuB;AACpCC,cAAYC,cAAZ,EAA4B;AAC1B,SAAKC,KAAL,GAAa,mBAASD,cAAT,EAAyB,IAAzB,CAAb;AACA,SAAKE,KAAL,GAAa,CAAb;AACD;;AAEDC,qBAAmBC,YAAnB,EAAiC;AAC/B,QAAIC,UAAU,YAAW;AACvB,aAAOC,KAAKC,KAAL,CAAYD,KAAKE,MAAL,KAAgBJ,YAAhB,GAA+B,EAAhC,GAAsC,CAAjD,CAAP;AACD,KAFD;AAGA,QAAIK,OAAO,IAAIX,gBAAJ,CAAqBO,SAArB,CAAX;;AAEA,WAAO,KAAKK,OAAL,KAAiBN,YAAxB,EAAsC;AACpC,WAAKO,MAAL,CAAYN,SAAZ;AACD;AACF;;AAEDO,YAAU;AACR,WAAO,KAAKX,KAAZ;AACD;;AAEDS,YAAU;AACR,WAAO,KAAKR,KAAZ;AACD;;AAEDS,SAAOE,UAAP,EAAmB;AACjB,QAAIC,cAAc,KAAKF,OAAL,EAAlB;AACA,QAAIG,QAAQ,KAAZ;;AAEA,WAAMA,UAAU,KAAhB,EAAuB;AACrB,UAAIF,eAAeC,YAAYE,aAAZ,EAAnB,EAAgD;AAC9C,eAAO,KAAP,CAD8C,CAChC;AACf,OAFD,MAGK,IAAIH,aAAaC,YAAYE,aAAZ,EAAjB,EAA8C;AACjD,YAAIF,YAAYG,YAAZ,OAA+B,IAAnC,EAAyC;AACvCH,sBAAYI,YAAZ,CAAyB,mBAASL,UAAT,EAAqBC,WAArB,CAAzB;AACAC,kBAAQ,IAAR;AACD,SAHD,MAIK;AACHD,wBAAcA,YAAYG,YAAZ,EAAd;AACD;AACF,OARI,MASA;AACH,YAAIH,YAAYK,WAAZ,OAA8B,IAAlC,EAAwC;AACtCL,sBAAYM,WAAZ,CAAwB,mBAASP,UAAT,EAAqBC,WAArB,CAAxB;AACAC,kBAAQ,IAAR;AACD,SAHD,MAIK;AACHD,wBAAcA,YAAYK,WAAZ,EAAd;AACD;AACF;AACF;;AAED,SAAKjB,KAAL;AACA,WAAO,IAAP;AACD;;AAEDmB,qBAAmB;AACjB,QAAIC,QAAQ,EAAZ;AACA,QAAIC,UAAU,EAAd;AACA,QAAIT,cAAc,KAAKF,OAAL,EAAlB;;AAEA,QAAIE,YAAYE,aAAZ,OAAgC,IAApC,EAA0C;AACxC,aAAOM,KAAP;AACD;;AAED;AACA,WAAOC,QAAQC,MAAR,GAAiB,KAAKd,OAAL,EAAxB,EAAwC;AACtC;AACA,aAAO,CAACa,QAAQE,QAAR,CAAiBX,WAAjB,CAAR,EAAuC;AACrC;AACA,eAAOA,YAAYK,WAAZ,MAA6B,IAA7B,IAAqC,CAACI,QAAQE,QAAR,CAAiBX,YAAYK,WAAZ,EAAjB,CAA7C,EAA0F;AACxFL,wBAAcA,YAAYK,WAAZ,EAAd;AACD;;AAED;AACAG,cAAMI,IAAN,CAAWZ,YAAYE,aAAZ,EAAX;AACAO,gBAAQG,IAAR,CAAaZ,WAAb;;AAEA;AACA,YAAIA,YAAYG,YAAZ,MAA8B,IAA9B,IAAsC,CAACM,QAAQE,QAAR,CAAiBX,YAAYG,YAAZ,EAAjB,CAA3C,EAAyF;AACvFH,wBAAcA,YAAYG,YAAZ,EAAd;AACD;AACF;;AAED;AACA,aAAOH,YAAYa,SAAZ,MAA2B,IAA3B,IAAmCJ,QAAQE,QAAR,CAAiBX,YAAYa,SAAZ,EAAjB,CAA1C,EAAqF;AACnFb,sBAAcA,YAAYa,SAAZ,EAAd;AACD;;AAED;AACA,UAAIb,YAAYa,SAAZ,MAA2B,IAA/B,EAAqC;AACnCb,sBAAcA,YAAYa,SAAZ,EAAd;AACD;AACF;;AAED,WAAOL,KAAP;AACD;;AAEDM,WAASf,UAAT,EAAqB;AACnB,QAAIC,cAAc,KAAKF,OAAL,EAAlB;;AAEA,WAAME,eAAe,IAAf,IAAuBD,cAAcC,YAAYE,aAAZ,EAA3C,EAAwE;AACtE,UAAIH,aAAaC,YAAYE,aAAZ,EAAjB,EAA8C;AAC5CF,sBAAcA,YAAYG,YAAZ,EAAd;AACD,OAFD,MAGK;AACHH,sBAAcA,YAAYK,WAAZ,EAAd;AACD;AACF;;AAED,WAAOL,WAAP;AACD;AAhHmC;kBAAjBhB,gB","file":"BinarySearchTree.js","sourcesContent":["import Node from './Node'\n\nexport default class BinarySearchTree {\n  constructor(rootComparable) {\n    this._root = new Node(rootComparable, null);\n    this._size = 1;\n  }\n\n  initiateRandomTree(nrOfElements) {\n    var mRandom = function() {\n      return Math.floor((Math.random() * nrOfElements * 10) + 1);\n    }\n    var tree = new BinarySearchTree(mRandom());\n\n    while (this.getSize() < nrOfElements) {\n      this.insert(mRandom());\n    }\n  }\n\n  getRoot() {\n    return this._root;\n  }\n\n  getSize() {\n    return this._size;\n  }\n\n  insert(comparable) {\n    let currentNode = this.getRoot();\n    let added = false;\n\n    while(added === false) {\n      if (comparable === currentNode.getComparable()) {\n        return false; //Comparable already in tree.\n      }\n      else if (comparable > currentNode.getComparable()) {\n        if (currentNode.getRightTree() === null) {\n          currentNode.setRightTree(new Node(comparable, currentNode));\n          added = true;\n        }\n        else {\n          currentNode = currentNode.getRightTree();\n        }\n      }\n      else {\n        if (currentNode.getLeftTree() === null) {\n          currentNode.setLeftTree(new Node(comparable, currentNode));\n          added = true;\n        }\n        else {\n          currentNode = currentNode.getLeftTree();\n        }\n      }\n    }\n\n    this._size++;\n    return true;\n  }\n\n  inOrderTraversal() {\n    var array = [];\n    var visited = [];\n    var currentNode = this.getRoot();\n\n    if (currentNode.getComparable() === null) {\n      return array;\n    }\n\n    //While all nodes have not been visited\n    while (visited.length < this.getSize()) {\n      //While current node is not visited\n      while (!visited.includes(currentNode)) {\n        //Go to most left node from currentNode\n        while (currentNode.getLeftTree() != null && !visited.includes(currentNode.getLeftTree())) {\n          currentNode = currentNode.getLeftTree();\n        }\n\n        //Put currentNode in array and mark currentNode as visited\n        array.push(currentNode.getComparable());\n        visited.push(currentNode);\n\n        //Go to right node if there is one\n        if (currentNode.getRightTree() != null && !visited.includes(currentNode.getRightTree())) {\n          currentNode = currentNode.getRightTree();\n        }\n      }\n\n      //Go back to firstNode with an unvisited parent\n      while (currentNode.getParent() != null && visited.includes(currentNode.getParent())) {\n        currentNode = currentNode.getParent();\n      }\n\n      //If not rootNode go to the unvisited parent\n      if (currentNode.getParent() != null) {\n        currentNode = currentNode.getParent();\n      }\n    }\n\n    return array;\n  }\n\n  findNode(comparable) {\n    var currentNode = this.getRoot();\n\n    while(currentNode != null && comparable != currentNode.getComparable()) {\n      if (comparable > currentNode.getComparable()) {\n        currentNode = currentNode.getRightTree();\n      }\n      else {\n        currentNode = currentNode.getLeftTree();\n      }\n    }\n\n    return currentNode;\n  }\n}\n"]}